\chapter{Análisis crítico}

\section{Reflexión sobre las propuestas más adecuadas para el contexto educativo}
Teniendo en cuenta el contexto educativo específico del curso, que prioriza la comprensión general de los fundamentos detrás del funcionamiento de los sistemas ope-rativos sobre las nuevas ideas y enfoques modernos. También, teniendo en cuenta el nivel de complejidad, accesibilidad y documentación disponible en internet; hemos llegado a las siguientes propuestas:
\begin{itemize}
    \item \textbf{Minix:} Este sistema operativo fue diseñado acorde al objetivo de nuestro curso, el hecho de contar con una arquitectura bien definida (microkernel) y documentada, suman puntos a su favor para ser elegida como objeto de estudio y mejora. Además es conisderado un sistema operativo de complejidad baja debido al pequeño tamaño de su código fuente y sus componentes.
    \item \textbf{XV6:} Este sistema también es una excelente opción de estudio, también es acorde al propósito del curso, su arquitectura monolítica es la más sencilla de entender, está muy bien documentada y su código fuente es en extremo pequeño en comparación con otras opciones, ya que tiene aproximadamente solo 10,000 líneas de código. Además, al estar basado en Unix es un sistema ricamente educativo.
\end{itemize}
A modo de justificar nuestra elección, expondremos a continuación la reflexión sobre las demás propuestas, empezando por las que podrían ser candidatas suplentes, en caso de no poder trabajar con las elegidas anteriormente.
Considerando opciones que requieren más investigación y tiempo de estudio debido a su tamaño y complejidad, pero que aún son viables para este proyecto:
\begin{itemize}
    \item \textbf{HelenOS:} Es un proyecto bastante bien documentado (incluye bastantes diagramas) y con un contenido altamente educativo, especialmente para entender modularidad, comunicación por IPC y arquitectura microkernel multiserver. La única razon de estar en esta categoría es su tamaño y complejidad.
    \item \textbf{RedoxOS:} Este sistema operativo también tiene una buena cantidad de documentación; en lo educativo, aparte de la modularidad y seguridad (aislamiento), trae un concepto innovador, los drivers en espacio de usuario. Las razones para estar en esta categoría son su tamaño, complejidad y estar escrito en Rust.
    \item \textbf{FreeRTOS:} Este sistema es una opción interesante; sin embargo, no va acorde al objetivo del curso, ya que es de tiempo real y orientado a sistemas embebidos; sus conceptos más educatviso son concurrencia y temporización.
\end{itemize}
Sobre los demás sistemas, como  TheseusOS, FlexOS y LibrettOS, fueron catalogados en este entregable en el rango de dificultad de media-alta a altísima, debido a que son bastante innovadores con paradigmas inexplorados (TheseusOS) o bien son sistemas muy nuevos (Librettos) o tienen dependencias técnicas muy avanzadas (FlexOS); estos tres sistemas están más orientados a proyectos de investigación muy específicos y proyectos de posgrado.
Sobre HaikuOS y FreeDOS, HaikuOS fue descartado debido a que la mejor referencia no es accesible de forma gratuita, y la documentación disponible no está bien organizada, además mucha de la documentación se basa más en BeOS (un sistema antiguo), que en lo nuevo de HaikuOS; con FreeDOS, fue descartado para este proyecto debido a su antigüedad y falta de características modernas, sin embargo, aún podría ser estudiado para comprender el arranque de la PC, cabe resaltar que posee una gran documentación y estudios a sus alrededor.

\section{Identificación de patrones comunes y enfoques divergentes}
\subsection{Patrones Comunes}
\begin{itemize}
    \item \textbf{Modularidad y aislamiento:} La mayoría de sistemas analizados usan arquitecturas que permiten modularidad, como microkernel, híbridas o incluso la arquitectura en cells de TheseusOS, en general los proyectos modernos buscan la modularidad en sus componentes para facilitar la corrección de errores sin reiniciar.
    \item \textbf{Lenguaje de implementación:} Casi todos los sistemas operativos analizados se implementan en lenguajes de bajo nivel, como C, C++ y emsamblador, solo algunos proyectos modernos orientados a seguridad utilizan Rust como lenguaje principal. 
    \item \textbf{Virtualización:} Usar herramientas de virtualización como QEMU o VirtualBox es casi universal, para desarrollar, probar y ejecutar; en casi todos los proyectos analizados. 
    \item \textbf{Comunicación por IPC:} Los sistemas que tiene una arquitectura modular, usan mensajes IPC para poder comunicar sus componentes entre sí, dentro de los cuales también se encuentran patrones com la implementación de multitarea y scheduling de procesos. 
\end{itemize}
\subsection{Enfoques Divergentes}
\begin{itemize}
    \item \textbf{Arquitectura en cells:} La arquitectura de TheseusOS es una manera única e innovadora de diseñar un sistema operativo, con un enfoque en modularidad extrema para mejorar la recuperación ante fallos y actualización en caliente (hot swap). Consideramos una idea bastante robusta y novedosa para implementar al proyecto propio. Sin embargo, la complejidad de un arquitectura en cells es altísima, razón por la cual no será implementada en este proyecto. 
    \item \textbf{Administración de privilegios:} TheseusOS diverge de los demás sistemas analizados, al presentar un único nivel de privilegios acompañado de un único espacio de direcciones, este enfoque es muy atractivo para implementar en el proyecto propio porque permite una gran funcionalidad y robustez con una idea bastante simple (SAS).
    \item \textbf{Flexibilidad de aislamiento:} En FlexOS el nivel de aislamiento de un componente es flexible, o sea puede ser ajustado según conveniencia, para obtener las ventajas de una arquitectura monolítica o microkernel según se quiera.
    \item \textbf{Enfoque en hardware:} LibrettOS se caracteriza por su reutilización de drivers y la pila de NetBSD, utiliza hipervisores y hardware especializado para un aislmiento profundo.
    \item \textbf{Enfoque histórico:} FreeDOS es un proyecto enfocado en comprender la arquitectura x86 y el arranque BIOS de la PC, funciona en 16 bits y carece de casi todos los conceptos de sistemas operativos modernos.
\end{itemize}

\section{Dificultades técnicas recurrentes}
Estos sistemas en general presentan las siguientes dificultades técnicas:
\begin{itemize}
    \item \textbf{Aprendizaje del lenguaje:} Los sistemas operativos analizados están escritos en C, C++ o Rust, lenguajes cuya curva de aprendizaje es bastante brusca y sobre todo al crear un sistema operativo, con conceptos tan díficiles como templates, ownership y lifetimes.
    \item \textbf{Complejidad de compilación:} Muchos de los sistemas analizados requieren configuraciones de compilación complejas, como toolchains de compilación cruzada, algunos incluso piden entornos de construcción especializados. Además, el más común "QEMU" tampoco es intuitivo de configurar y no posee tanta documentación en español.
    \item \textbf{Virtualización avanzada:} La instalación de LibrettOS requiere del uso de hipervisores y hardware especializado, y si no se cuenta con ello, se debe recurrir a emuladores todavía más complicados y especializados.
    \item \textbf{Abstracción de arquitectura:} Entre los sistemas analizados, resalta la arquitectura microkernel multiserver, la cual exige una organización y planificación exhaustiva de los componentes a implementar, exige pensar el servicios y servidores de estos, implica mucha abstracción y modularidad.
    \item \textbf{Conocimiento de bajo nivel:} Para optimizar el funcionamiento de sistemas operativos, es necesario comprender de manera profunda como funciona la interacción con el hardware y los recursos de la computadora, por lo que es necesario conocer emsamblador para el manejo de interrupciones, gestión de memoria y demás tareas del SO.
\end{itemize}

\section{Posibles fuentes de inspiración para el proyecto propio}
Para el proyecto propio, en el tercer entregable se podrían extraer ideas de los siguientes sistemas operativos analizados:
\begin{itemize}
    \item \textbf{MINIX:} MINIX sirve como motivación por su arquitectura basada en microkernel, ya que los servicios del sistema operativo se ejecutan en procesos separados, el diseño ayuda en la comprensión de los conceptos de aislamiento e independencia entre componentes. Para nuestro proyecto, podemos emularlo manteniendo un código base reducido con fines educativos, así como su organización modular del código (por ejemplo, mediante directorios o archivos separados como fs/, , sh/, ipc.c, syscall.c). Además, el uso de IPC como mecanismo principal para una comunicación controlada entre procesos, es clave. También puede desarrollarse un sistema de archivos básico compatible con operaciones de montaje, que siga esta misma lógica de simplicidad y claridad en el diseño.
    \item \textbf{XV6:} La motivación para considerar XV6 es su simplicidad estructural, se trata de un sistema operativo cuyo código fuente es lo suficientemente conciso para ser analizado y comprendido en su totalidad en un semestre académico. Para nuestro proyecto, adoptar este enfoque es conveniente para desarrollar un núcleo (kernel) de tamaño reducido, con un diseño limpio y accesible para su estudio. Sería conveniente el uso de un round-robin y una organización del código en módulos educativos bien diferenciados (por ejemplo: proc.c, vm.c, fs.c o pipe.c). A su vez, se pueden utilizar los pipes (tuberías) como un mecanismo simple y replicable de comunicación entre procesos (IPC), replicando el modelo clásico de espacio de direcciones de Unix (que divide la memoria en regiones para código, datos, heap y stack, incluyendo una página de protección).
    \item \textbf{RedoxOS:} De RedoxOS nos inspira su modernidad, seguridad y modularidad a través de su desarrollo en Rust. El proyecto permite diseñar un kernel mínimo que incluya servicios externos, como drivers, sistemas de archivos o redes, utilizando Rust o integrando principios de seguridad de memoria en las partes más críticas del sistema operativo. Es importante crear un mecanismo de comunicación modular, similar a los schemes, con el objetivo de unificar la API de los servicios y implementar un sistema de archivos sencillo inspirado en RedoxFS. La separación clara entre el kernel y los servicios debe priorizar el aislamiento y la estabilidad del sistema, y se puede lograr utilizando QEMU junto con contenedores para asegurar un flujo de desarrollo reproducible.
    \item \textbf{HelenOS:} Lo que más nos servirá de inspiración de este sistema operativo es su arquitectura microkernel multiserver, donde la idea clave es implementar un kernel muy pequeño y manejar los servicios en el espacio de usuario. Al igual que en Theseus (el cual también fue una inspiración, aunque no es viable hacer el tercer entregable sobre él), se aplica la modularidad para permitir recuperación ante fallos sin reiniciar el kernel, además de diseñar componentes aislados con su propio espacio de direcciones. Se usará comunicación por mensajes IPC, para comunicar los componentes y es recomendable separar los drivers en forma de un árbol, de manera jerarquizada.
\end{itemize}