\chapter{Diseño del sistema operativo propuesto}

Este capítulo presenta el diseño del sistema operativo HelenOS, Diseñado a partir de una arquitectura de micronúcleo y entornos operativos
multiservidor \citep{decky2015application,decky2010road,helenos_GitHub}. Se detallan el diseño estructural y los módulos esenciales para el desarrollo, 
las políticas de planificación y manejo de recursos y el flujo de ejecución esperado desde el arranque hasta la interacción del usuario.
Se implementa un núcleo básico apoyado por múltiples servidores que operan en el área de usuario como redes, archivos y controladores, comunicándose
mediante paso de mensajes asíncrono \citep{decky2015application}. Ademas se inspirado en Unix/POSIX, evita interfaces heredadas cuando 
existen alternativas modernas, como por ejemplo, prescinde de los sockets de POSIX y expone una API orientada a flujos TCP \citep{korop2025packet,helenos_project}.
La ruta de la comunicación de red atraviesa por procesos (NIC \textrightarrow{} Ethernet \textrightarrow{} IP \textrightarrow{} TCP) 
antes de llegar a la aplicación, reforzando el aislamiento y la modularidad \citep{korop2025packet}.
Finalmente, los ejecutables siguen el formato ELF con soporte de enlace dinámico, PIE y TLS, preparados por un servidor de carga antes del inicio de cada tarea \citep{volf2025rust}.

\section{Diagrama de arquitectura general}
El sistema operativo HelenOS está diseñado como un microkernel relativamente pequeño, asistido por un conjunto de controladores de espacio
de usuario y tareas de servidor. HelenOS no es muy radical en cuanto a qué subsistemas deben o no implementarse en el kernel, en algunos
casos, existen tanto controladores de kernel como de espacio de usuario. La razón para crear el sistema como un microkernel es prosaica.
Si bien inicialmente es más difícil obtener el mismo nivel de funcionalidad de un microkernel que en el caso de un kernel monolítico simple,
un microkernel es mucho más fácil de mantener una vez que sus componentes se han puesto en funcionamiento. Por lo tanto, el kernel de HelenOS,
así como sus bibliotecas esenciales de espacio de usuario, solo pueden ser mantenidas por unos pocos desarrolladores que las comprendan completamente.
Además, un sistema operativo basado en microkernel se completa antes que los kernels monolíticos, ya que el sistema puede utilizarse
incluso sin algunos subsistemas tradicionales (por ejemplo, dispositivos de bloque, sistemas de archivos y redes). Segun \citep{helenos_design_2006}.

Pordemos observar el diagrama de arquitectura general en la Figura \ref{fig:Arquitectura HelenOS}.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/Arquitectura HelenOS.png}
	\caption{Diseño general de HelenOS y organización multiservidor basada en microkernel (fuente: \citep{helenos_design_2006}).}
	\label{fig:Arquitectura HelenOS}
\end{figure}

\section{Componentes a implementar}

\subsection{Bootloader}
En la arquitectura x86-64, HelenOS emplea el gestor de arranque GRUB (Grub boot loader). Segun \citep{helenos_wiki_tutorial} para iniciar el sistema. Este se encarga de cargar el kernel junto
con un conjunto inicial de tareas de espacio de usuario necesarias para completar el proceso de arranque. Asimismo, GRUB carga un disco
RAM que contiene el sistema de archivos raíz. Durante las fases iniciales del arranque, el sistema muestra mensajes de registro generados
tanto por el kernel como por las tareas de espacio de usuario a medida que se inicializan. Una vez completado este proceso, el compositor
de la interfaz gráfica toma control de la pantalla, momento en el cual el sistema ya cuenta con más de 35 tareas de espacio de usuario en
ejecución, responsables de proporcionar la funcionalidad básica del sistema.
Según la documentación de diseño y del propio proyectos \citep{helenos_design_2006,helenos_prjdoc_2006}.

\subsection{Kernel básico}
Segun \citep{decky2010road}El planificador de HelenOS mantiene varias colas de ejecución asociadas a cada procesador. Los hilos preparados para ejecutarse se insertan en estas colas de acuerdo con su nivel
de prioridad y el procesador actual, desde donde son seleccionados para su ejecución. Para garantizar un reparto equilibrado de la carga, existen hilos del núcleo con funciones
especiales encargados de migrar hilos entre procesadores cuando es necesario. La planificación se basa en una política de round-robin aplicada sobre múltiples colas de prioridad.

Aunque el diseño del micronúcleo prioriza la simplicidad conceptual, HelenOS hace uso de mecanismos modernos y eficientes, incluyendo árboles AVL y B+, tablas hash, un asignador
de memoria SLAB, con el objetivo de mejorar el rendimiento y la escalabilidad del sistema.

El microkernel de HelenOS está organizado en subsistemas especializados que gestionan los recursos esenciales del sistema. 
La Tabla \ref{tab:subsistemas-kernel} presenta los tres pilares fundamentales: programación, gestión de memoria y comunicación 
entre procesos, detallando los mecanismos clave que implementa cada uno \citep{helenos_design_2006,decky2010road}.

\begin{longtable}{|p{4.5cm}|p{5cm}|p{5cm}|}
\caption{Subsistemas fundamentales del kernel de HelenOS}
\label{tab:subsistemas-kernel} \\
\hline
\textbf{Subsistema del Kernel} & \textbf{Entidades / Mecanismos} & \textbf{Función Principal} \\ \hline
\endfirsthead

\multicolumn{3}{c}%
{{\tablename\ \thetable{} -- continuación de la página anterior}} \\
\hline
\textbf{Subsistema del Kernel} & \textbf{Entidades / Mecanismos} & \textbf{Función Principal} \\ \hline
\endhead

\endfoot

\hline
\endlastfoot

Programación (Scheduling) & Hilos del kernel, hilos de usuario, pseudohilos, tareas, colas de ejecución multinivel, planificador round-robin con prioridades, balanceo de carga entre CPUs & Gestionar la ejecución concurrente de múltiples tareas, asignar tiempo de CPU según prioridad, mantener el equilibrio de carga entre procesadores y soportar sistemas multiprocesador (SMP) \\ \hline

Gestión de Memoria & Asignador de bloques, asignador de tramas físicas (buddy system), traducción virtual-física mediante tablas de páginas, espacios de direcciones aislados, áreas de memoria compartidas, coherencia TLB & Asignar memoria dinámica al kernel y a las tareas de usuario, traducir direcciones virtuales a físicas, aislar espacios de memoria entre procesos, gestionar memoria compartida y garantizar coherencia en sistemas multiprocesador \\ \hline

Comunicación entre Procesos (IPC) & Mensajes cortos síncronos/asíncronos, \textit{teléfonos} (canales de comunicación), llamadas asíncronas con callbacks, cuadros de respuesta, áreas de memoria compartida para datos grandes & Permitir la comunicación eficiente y segura entre tareas del sistema en un entorno microkernel multiservidor, facilitando el paso de mensajes y compartición de datos entre procesos aislados \\ \hline

\end{longtable}

Esta arquitectura modular permite que el microkernel se mantenga compacto y simple, delegando funcionalidades complejas a servidores 
en espacio de usuario que se comunican mediante el sistema IPC del kernel.

\subsection{Gestión de procesos}
En HelenOS, el hilo es la unidad básica de ejecución del kernel y se agrupa en tareas según su funcionalidad. En el espacio de usuario se emplean fibrillas, hilos cooperativos
construidos sobre una API del núcleo y utilizados por el marco asíncrono. Debido a su arquitectura de micronúcleo, la comunicación entre procesos (IPC) es fundamental.
Las tareas intercambian información mediante mensajes breves o mediante el compartimiento de memoria para datos de mayor tamaño. El modelo de IPC permite múltiples conexiones
simultáneas entre tareas. \citep{helenos_design_2006,jindrak2022cpp}.

\subsubsection*{Aspectos esenciales del manejo de hilos y tareas}

\textbf{Hilos y tareas.}
Una tarea representa un espacio de direcciones y recursos, mientras que el hilo es la unidad básica de ejecución. Cada tarea se inicia con un hilo principal creado por el cargador y registrado en el planificador del sistema.

\textbf{Planificación y ejecución.}
Los hilos pasan por los estados \emph{listo}, \emph{ejecutando} y \emph{bloqueado}. El planificador selecciona el hilo a ejecutar según prioridades y políticas de reparto justo, utilizando preempción basada en temporizadores.

\textbf{Conmutación de contexto.}
La conmutación de contexto ocurre ante interrupciones, llamadas al sistema o bloqueos. El kernel guarda el estado del hilo actual y restaura el del siguiente, permitiendo la ejecución concurrente eficiente.

\textbf{Comunicación entre procesos (IPC).}
El modelo cliente--servidor permite la comunicación mediante mensajes y, cuando es necesario, memoria compartida. El cliente envía una solicitud, el servidor la procesa y responde, desbloqueando al cliente.

\textbf{Creación y finalización.}
El cargador valida y carga el ejecutable, crea las áreas de memoria y el hilo inicial. Al finalizar un hilo, se liberan sus recursos; si la tarea queda sin hilos activos, el sistema libera completamente la tarea.


\subsection{Gestión de memoria}
HelenOS garantiza la coherencia entre la TLB y las tablas de páginas mediante un mecanismo de invalidación coordinada en sistemas multiprocesador. La gestión de memoria del
sistema cubre la asignación para el kernel, la traducción de direcciones virtuales y la administración de espacios de direcciones. Cada espacio de direcciones está compuesto
por áreas disjuntas respaldadas por memoria anónima, imágenes ejecutables o memoria física. El sistema permite compartir áreas entre tareas, pero no soporta intercambio de
páginas con almacenamiento secundario. \citep{helenos_design_2006}
\begin{longtable}{|p{4.2cm}|p{7.3cm}|p{4.2cm}|}
\caption{Aspectos esenciales de la gestión de memoria en HelenOS}
\label{tab:gestion-memoria-resumen} \\
\hline
\textbf{Componente} & \textbf{Descripción técnica} & \textbf{Objetivo / Beneficio} \\
\hline
\endfirsthead

\multicolumn{3}{c}{{\tablename\ \thetable{} -- continuación}} \\
\hline
\textbf{Componente} & \textbf{Descripción técnica} & \textbf{Objetivo / Beneficio} \\
\hline
\endhead

\endfoot
\hline
\endlastfoot

Zonas y marcos físicos &
La memoria física se organiza en zonas contiguas que contienen marcos (\textit{frames}) administrados mediante un \textit{buddy system}. Cada zona mantiene contadores de marcos libres y ocupados. &
Permitir asignación eficiente de bloques contiguos y escalabilidad del sistema de memoria física. \\
\hline

Asignador de marcos &
El \textit{frame allocator} gestiona solicitudes de memoria en potencias de dos dentro de una zona, utilizando el \textit{buddy allocator}. &
Asignación rápida y consistente de memoria física alineada. \\
\hline

Slab allocator &
Asignador de objetos pequeños y frecuentes basado en \textit{slabs} y \textit{magazines} por CPU, evitando bloqueos globales. &
Reducir fragmentación interna y mejorar concurrencia y rendimiento del kernel. \\
\hline

Memoria virtual &
HelenOS implementa paginación mediante una interfaz genérica que soporta tablas jerárquicas o tabla hash global según la arquitectura. &
Abstraer diferencias de hardware y unificar la gestión de memoria virtual. \\
\hline

Espacios de direcciones &
Cada tarea posee un espacio de direcciones con áreas disjuntas organizadas en un B+\,tree; el kernel se mapea fuera de estas áreas. &
Aislamiento entre procesos y gestión independiente de regiones de memoria. \\
\hline

Áreas y permisos &
Las áreas definen regiones homogéneas con permisos de lectura, escritura y ejecución, evitando combinaciones inseguras como WRITE+EXEC. &
Control fino de protección y seguridad de memoria. \\
\hline

Compartición de memoria &
Las áreas pueden compartirse entre tareas mediante estructuras de referencia y un \textit{pagemap} común. &
Comunicación eficiente entre procesos sin duplicar memoria. \\
\hline

Page faults &
Los fallos de página se resuelven bajo demanda según el backend del área (anónima, ELF o física). &
Carga diferida de memoria y uso eficiente de recursos. \\
\hline

TLB y coherencia &
El sistema mantiene coherencia entre TLB y tablas de páginas mediante invalidaciones y \textit{TLB shootdown} en sistemas SMP. &
Garantizar consistencia y corrección en ejecución multiprocesador. \\
\hline

\end{longtable}

\subsection{Sistema de archivos}
El sistema operativo HelenOS tiene soporte de sistemas de archivos basado en un Sistema de Archivos Virtual (VFS), que actúa como una capa de abstracción entre las
aplicaciones y los distintos sistemas de archivos. El VFS se implementa como un servidor central encargado de unificar el acceso a los dispositivos de almacenamiento.
Cada sistema de archivos se ejecuta como un servicio independiente en espacio de usuario y registra sus capacidades en el VFS. El VFS proporciona una interfaz común de
operaciones y ofrece compatibilidad con POSIX mediante una capa de adaptación. Su diseño se divide en un frontend, que gestiona solicitudes simples, y un backend, que
delega las operaciones al servidor de archivos correspondiente. \citep{zarevucky2012improved,cimerman2025raid}.

La Tabla \ref{tab:vfs-componentes} detalla los componentes principales del subsistema de archivos de HelenOS, incluyendo el servidor VFS central, 
los servidores de sistemas de archivos específicos y los componentes de soporte que permiten la gestión unificada del almacenamiento en un entorno 
multiservidor \citep{zarevucky2012improved,helenos_design_2006}.

\begin{longtable}{|p{4.2cm}|p{4.2cm}|p{6.1cm}|}
\caption{Componentes principales del subsistema de archivos en HelenOS}
\label{tab:vfs-componentes} \\
\hline
\textbf{Componente} & \textbf{Ubicación / Tipo} & \textbf{Función principal} \\
\hline
\endfirsthead

\multicolumn{3}{c}{{\tablename\ \thetable{} -- continuación}} \\
\hline
\textbf{Componente} & \textbf{Ubicación / Tipo} & \textbf{Función principal} \\
\hline
\endhead

\endfoot
\hline
\endlastfoot

VFS (Virtual File System) &
Servidor central en espacio de usuario &
Proporciona una interfaz unificada de acceso a archivos, mantiene el árbol global de directorios y coordina las operaciones entre aplicaciones y servidores de sistemas de archivos \\ \hline

Servidores de sistemas de archivos &
Servidores independientes en espacio de usuario &
Implementan la lógica específica de cada sistema de archivos (FAT, ext2, tmpfs, etc.) y gestionan estructuras y metadatos del almacenamiento \\ \hline

Frontend VFS &
Módulo interno del servidor VFS &
Atiende llamadas básicas de aplicaciones (\texttt{open}, \texttt{read}, \texttt{write}, \texttt{close}), administra descriptores y controla archivos abiertos \\ \hline

Backend VFS &
Módulo interno del servidor VFS &
Traduce operaciones genéricas en solicitudes específicas del sistema de archivos correspondiente y coordina el acceso concurrente \\ \hline

Capa de compatibilidad POSIX &
Biblioteca \texttt{libc} en espacio de usuario &
Mapea llamadas POSIX estándar a la API nativa de HelenOS, permitiendo la portabilidad de aplicaciones \\ \hline

Controladores de dispositivos de bloque &
Servidores de dispositivos en espacio de usuario &
Gestionan el acceso a dispositivos de almacenamiento y proporcionan una interfaz de bloques al VFS \\ \hline

Caché de bloques &
Componente del servidor VFS &
Optimiza el rendimiento almacenando bloques frecuentes en memoria y reduciendo accesos a disco \\ \hline

Registro de montajes &
Estructura interna del VFS &
Mantiene información de volúmenes montados, puntos de montaje y servidores responsables \\ \hline

\end{longtable}



Este diseño modular permite que cada sistema de archivos funcione como un proceso independiente, mejorando la estabilidad del sistema ya que 
un fallo en un servidor de archivos no afecta al VFS ni a otros sistemas de archivos montados.
\subsection{Interfaz de usuario}
HelenOS proporciona una interfaz de usuario básica basada en texto, sin soporte gráfico integrado en el núcleo. La interacción con el sistema se realiza mediante un shell en
espacio de usuario, denominado Bdsh, encargado de interpretar comandos, ejecutar aplicaciones y gestionar la entrada y salida estándar. Dado su enfoque como sistema operativo
de investigación, el entorno de usuario es minimalista y se limita a una interfaz de línea de comandos (CLI). Las aplicaciones se comunican con los servidores del sistema a 
través del API de HelenOS, actuando el shell como un cliente de dichos servicios sin requerir soporte especial del kernel. Segun \citep{helenos_wiki_tutorial}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/Diseño de HelenOS.png}
	\caption{Diseño general de HelenOS y organización multiservidor basada en microkernel (fuente: \citep{helenos_wiki_tutorial}).}
	\label{fig:Interfaz HelenOS}
\end{figure}
\subsection{Políticas de planificación y manejo de recursos}
HelenOS emplea un planificador preventivo con retroalimentación de prioridad, compatible con sistemas SMP y diseñado para ser altamente
portable. Actualmente soporta múltiples arquitecturas de hardware, incluyendo x86, x86-64, IA64, SPARC, PowerPC, ARM y MIPS. Aunque no 
está orientado al uso general debido a la falta de aplicaciones de usuario, ya cuenta con subsistemas esenciales como sistemas de archivos
y redes TCP/IP. El planificador utiliza múltiples colas de ejecución por procesador y una política round-robin con prioridades, incorporando
migración de hilos para balancear la carga. El diseño del sistema sigue el principio de separación entre mecanismos y políticas, delegando
estas últimas al espacio de usuario. \citep{decky2010road,helenos_design_2006}.

\subsubsection*{Estrategias de planificación y gestión de recursos}
La Tabla \ref{tab:planificacion-recursos} presenta las principales políticas y mecanismos que emplea HelenOS para gestionar la 
planificación de hilos, la distribución de carga en sistemas multiprocesador y el manejo eficiente de recursos del sistema, siguiendo 
el principio de separación entre mecanismos (implementados en el kernel) y políticas (definidas en espacio de usuario) 
\citep{decky2010road,helenos_design_2006}.

\begin{longtable}{|p{4.1cm}|p{5.1cm}|p{5.8cm}|}
\caption{Políticas de planificación y manejo de recursos en HelenOS}
\label{tab:planificacion-recursos} \\
\hline
\textbf{Política / Mecanismo} & \textbf{Descripción técnica (resumen)} & \textbf{Objetivo / Beneficios} \\
\hline
\endfirsthead

\multicolumn{3}{c}{{\tablename\ \thetable{} -- continuación}} \\
\hline
\textbf{Política / Mecanismo} & \textbf{Descripción técnica (resumen)} & \textbf{Objetivo / Beneficios} \\
\hline
\endhead

\endfoot
\hline
\endlastfoot

Planificación Round--Robin con prioridades &
Cada CPU mantiene colas por nivel de prioridad; los hilos rotan con quantum fijo y se atienden primero las colas de mayor prioridad. &
Reparto justo de CPU y respeto de prioridades, evitando inanición mediante envejecimiento. \\
\hline

Afinidad de CPU y migración de hilos &
El planificador favorece la ejecución en la CPU previa para aprovechar caché; hilos del kernel migran hilos si detectan desbalance de carga. &
Mejor rendimiento por localidad de caché y balance eficiente en sistemas SMP. \\
\hline

Planificación preventiva &
El kernel interrumpe hilos mediante temporizador, sin depender de cesión voluntaria de CPU. &
Evitar monopolio del procesador y garantizar buena respuesta interactiva. \\
\hline

Retroalimentación de prioridad &
La prioridad se ajusta dinámicamente según uso de CPU e I/O del hilo. &
Equilibrar throughput y tiempo de respuesta, favoreciendo tareas interactivas. \\
\hline

Separación mecanismo--política &
El kernel implementa mecanismos genéricos; las políticas se definen en servidores de usuario. &
Flexibilidad y experimentación sin modificar el kernel. \\
\hline

Quantum de tiempo adaptativo &
La duración del quantum varía según tipo de hilo y carga del sistema. &
Reducir overhead de cambio de contexto y mejorar interactividad. \\
\hline

Gestión de recursos por servidor &
La gestión de memoria, archivos e IPC se delega a servidores de usuario. &
Aislamiento, modularidad y tolerancia a fallos. \\
\hline

Soporte multiprocesador (SMP) &
El planificador usa estructuras con bloqueo fino para múltiples CPUs. &
Escalabilidad y máximo paralelismo en hardware multicore. \\
\hline

\end{longtable}


Esta arquitectura flexible permite que HelenOS se adapte a diferentes cargas de trabajo y objetivos de rendimiento sin requerir 
recompilación del kernel, manteniendo la simplicidad conceptual del microkernel.


\subsection{Flujo de ejecución básico}
El flujo de ejecución de HelenOS inicia con el bootloader, que carga el microkernel en memoria y transfiere el control. El kernel
inicializa el hardware esencial y habilita la planificación, la gestión de memoria y el IPC. Luego se lanzan los servidores fundamentales
en espacio de usuario, como controladores de dispositivos, VFS y servicios de nombres. Finalmente, se inicia el shell Bdsh, y el sistema
opera mediante múltiples tareas independientes que se comunican de forma concurrente a través del IPC del microkernel.\citep{helenos_design_2006}
